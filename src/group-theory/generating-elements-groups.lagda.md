# Generating elements of groups

```agda
module group-theory.generating-elements-groups where
```

<details><summary>Imports</summary>

```agda
open import commutative-algebra.commutative-rings

open import elementary-number-theory.integers

open import foundation.action-on-identifications-functions
open import foundation.dependent-pair-types
open import foundation.embeddings
open import foundation.equivalences
open import foundation.identity-types
open import foundation.images
open import foundation.injective-maps
open import foundation.propositional-maps
open import foundation.propositional-truncations
open import foundation.propositions
open import foundation.sets
open import foundation.subtypes
open import foundation.surjective-maps
open import foundation.unit-type
open import foundation.universe-levels

open import group-theory.abelian-groups
open import group-theory.addition-homomorphisms-abelian-groups
open import group-theory.commuting-elements-groups
open import group-theory.conjugation
open import group-theory.endomorphism-rings-abelian-groups
open import group-theory.free-groups-with-one-generator
open import group-theory.full-subgroups
open import group-theory.groups
open import group-theory.homomorphisms-groups
open import group-theory.integer-multiples-of-elements-abelian-groups
open import group-theory.integer-powers-of-elements-groups
open import group-theory.isomorphisms-abelian-groups
open import group-theory.normal-subgroups
open import group-theory.quotient-groups
open import group-theory.subgroups-generated-by-elements-groups
open import group-theory.subsets-groups
open import group-theory.trivial-group-homomorphisms

open import ring-theory.integer-multiples-of-elements-rings
open import ring-theory.rings
open import ring-theory.transporting-ring-structure-along-isomorphisms-abelian-groups
```

</details>

## Idea

An element $g$ of a [group](group-theory.groups.md) `G` is said to be a
**generating element** if the unique morphism `g̃ : ℤ → G` equipped with an
[identification](foundation-core.identity-types.md) `g̃(1) = {!!}
[surjective](foundation.surjective-maps.md).
[Equivalently](foundation.logical-equivalences.md), `g` is a generating element
if the [subgroup](group-theory.subgroups.md) `⟨g⟩` of `G`
[generated by the element](group-theory.subgroups-generated-by-elements-groups.md)
`g` is the [full subgroup](group-theory.full-subgroups.md) of `G`. We give in
total four different characterizations of the notion of generating element:

1. The subgroup generated by the element `g` is full.
2. The full subgroup of `G` is generated by the element `g`.
3. The group homomorphism `g̃ : ℤ → G` mapping `1` to `g` is surjective.
4. The evaluation map `hom(G,H) → H` at `g` is an embedding for every group `H`.

Of these four equivalent characterizations, we take the first as our standard
definition.

We note that the concept of _group equipped with a generating element_ is subtly
different from the concept of [cyclic group](group-theory.cyclic-groups.md).
Groups equipped with generating elements have a specified generating element as
part of their structure, whereas cyclic groups are groups with the
[property](foundation-core.propositions.md) that there
[exists](foundation.existential-quantification.md) a generating element.

Furthermore, we show that for any group `G` equipped with a generating element,
the evaluation map `hom(G,G) → G` is an
[equivalence](foundation.equivalences.md). Since groups equipped with a
generating element are [abelian](group-theory.abelian-groups.md), it follows
that `hom(G,G)` is the
[endomorphism ring](group-theory.endomorphism-rings-abelian-groups.md) of an
abelian group. The evaluation map on an endomorphism ring is always a group
homomorphism, so it follows from the
[isomorphism](group-theory.isomorphisms-groups.md)

```text
  hom(G,G) ≅ G
```

that any group equipped with a generating element is in fact a
[commutative ring](commutative-algebra.commutative-rings.md). Here we see
another difference between groups equipped with a specified generating element
and cyclic groups: Equipping a cyclic group with the structure of a commutative
ring amounts to equipping the cyclic group with a _specified_ generating
element, which corresponds to the unit element of the commutative ring
structure.

## Definitions

### Generating elements

We state the definition of generating elements in four equivalent ways: An
element `g` generates the group `G` if

1. the subgroup generated by the element `g` is full, or if
2. the full subgroup of `G` is generated by the element `g`, or if
3. the group homomorphism `g̃ : ℤ → G` mapping `1` to `g` is surjective, or if
4. the evaluation map `hom(G,H) → H` at `g` is an embedding for every group `H`.

#### The standard definition

```agda
module _
  {l : Level} (G : Group l) (g : type-Group G)
  where

  is-generating-element-prop-Group : Prop l
  is-generating-element-prop-Group = {!!}

  is-generating-element-Group : UU l
  is-generating-element-Group = {!!}

  is-prop-is-generating-element-Group : is-prop is-generating-element-Group
  is-prop-is-generating-element-Group = {!!}
```

#### The definition where the full subgroup is asserted to be generated by the element

```agda
  is-subgroup-generated-by-element-full-Subgroup : UUω
  is-subgroup-generated-by-element-full-Subgroup = {!!}
```

#### The definition where the unique morphism `ℤ → G` mapping `1` to `g` is surjective

```agda
module _
  {l : Level} (G : Group l)
  where

  is-surjective-hom-element-Group : type-Group G → UU l
  is-surjective-hom-element-Group g = {!!}
```

#### The definition where the evaluation map `hom(G,H) → H` at `g` is an embedding for every `H`

```agda
module _
  {l1 : Level} (G : Group l1) (g : type-Group G)
  where

  is-emb-ev-element-hom-Group' : (l : Level) → UU (l1 ⊔ lsuc l)
  is-emb-ev-element-hom-Group' l = {!!}

  is-emb-ev-element-hom-Group : UUω
  is-emb-ev-element-hom-Group = {!!}

  is-prop-map-ev-element-hom-Group : UUω
  is-prop-map-ev-element-hom-Group = {!!}
```

### The subset of generating elements of a group

```agda
module _
  {l : Level} (G : Group l)
  where

  generating-element-Group : subset-Group l G
  generating-element-Group x = {!!}
```

### Groups equipped with a generating element

```agda
Group-With-Generating-Element : (l : Level) → UU (lsuc l)
Group-With-Generating-Element l = {!!}

module _
  {l : Level} (G : Group-With-Generating-Element l)
  where

  group-Group-With-Generating-Element : Group l
  group-Group-With-Generating-Element = {!!}

  set-Group-With-Generating-Element : Set l
  set-Group-With-Generating-Element = {!!}

  type-Group-With-Generating-Element : UU l
  type-Group-With-Generating-Element = {!!}

  generating-element-Group-With-Generating-Element :
    type-subtype (generating-element-Group group-Group-With-Generating-Element)
  generating-element-Group-With-Generating-Element = {!!}

  element-Group-With-Generating-Element : type-Group-With-Generating-Element
  element-Group-With-Generating-Element = {!!}

  is-generating-element-element-Group-With-Generating-Element :
    is-generating-element-Group
      group-Group-With-Generating-Element
      element-Group-With-Generating-Element
  is-generating-element-element-Group-With-Generating-Element = {!!}

  ev-element-hom-Group-With-Generating-Element :
    (H : Group l) →
    hom-Group group-Group-With-Generating-Element H → type-Group H
  ev-element-hom-Group-With-Generating-Element H = {!!}
```

## Properties

### The four definitions of generating elements are equivalent

#### An element is generating if and only if it generates the full subgroup

```agda
module _
  {l : Level} (G : Group l) (g : type-Group G)
  where

  is-generating-element-is-subgroup-generated-by-element-full-Subgroup :
    is-subgroup-generated-by-element-full-Subgroup G g →
    is-generating-element-Group G g
  is-generating-element-is-subgroup-generated-by-element-full-Subgroup H x = {!!}

  is-subgroup-generated-by-element-full-subgroup-is-generating-element-Group :
    is-generating-element-Group G g →
    is-subgroup-generated-by-element-full-Subgroup G g
  pr1
    ( is-subgroup-generated-by-element-full-subgroup-is-generating-element-Group
      H K)
    ( u)
    ( x)
    ( v) = {!!}

is-subgroup-generated-by-element-full-subgroup-Group-With-Generating-Element :
  {l : Level} (G : Group-With-Generating-Element l) →
  is-subgroup-generated-by-element-full-Subgroup
    ( group-Group-With-Generating-Element G)
    ( element-Group-With-Generating-Element G)
is-subgroup-generated-by-element-full-subgroup-Group-With-Generating-Element G = {!!}
```

#### An element `g` is generating if and only if the unique map `g̃ : ℤ → G` is surjective

```agda
module _
  {l : Level} (G : Group l) (g : type-Group G)
  where

  is-generating-element-is-surjective-hom-element-Group' :
    (x : type-Group G) (k : ℤ) (p : map-hom-element-Group G g k ＝ x) →
    is-in-subgroup-element-Group G g x
  is-generating-element-is-surjective-hom-element-Group' ._ k refl = {!!}

  is-generating-element-is-surjective-hom-element-Group :
    is-surjective-hom-element-Group G g → is-generating-element-Group G g
  is-generating-element-is-surjective-hom-element-Group H x = {!!}

  is-surjective-hom-element-is-generating-element-Group :
    is-generating-element-Group G g → is-surjective-hom-element-Group G g
  is-surjective-hom-element-is-generating-element-Group H x = {!!}

is-surjective-hom-element-Group-With-Generating-Element :
  {l : Level} (G : Group-With-Generating-Element l) →
  is-surjective-hom-element-Group
    ( group-Group-With-Generating-Element G)
    ( element-Group-With-Generating-Element G)
is-surjective-hom-element-Group-With-Generating-Element G = {!!}
```

#### If the evaluation map `hom(G,H) → H` at `g` is an embedding for every group `H`, then `g̃ : ℤ → G` is surjective

```agda
module _
  {l : Level} (G : Group l) (g : type-Group G)
  (U : is-emb-ev-element-hom-Group G g)
  where

  compute-conjugation-is-emb-ev-element-hom-Group :
    htpy-hom-Group G G (conjugation-hom-Group G g) (id-hom-Group G)
  compute-conjugation-is-emb-ev-element-hom-Group = {!!}

  commute-is-emb-ev-element-hom-Group :
    (x : type-Group G) → mul-Group G g x ＝ mul-Group G x g
  commute-is-emb-ev-element-hom-Group x = {!!}

  compute-conjugation-is-emb-ev-element-hom-Group' :
    (x : type-Group G) → conjugation-Group G x g ＝ g
  compute-conjugation-is-emb-ev-element-hom-Group' x = {!!}

  abstract
    is-normal-image-hom-element-is-emb-ev-element-hom-Group :
      is-normal-Subgroup G (image-hom-element-Group G g)
    is-normal-image-hom-element-is-emb-ev-element-hom-Group x (y , p) = {!!}

  private
    N : Normal-Subgroup l G
    pr1 N = {!!}

    H : Group l
    H = {!!}

    q : hom-Group G H
    q = {!!}

  abstract
    is-trivial-quotient-hom-image-hom-element-is-emb-ev-element-hom-Group :
      is-trivial-hom-Group G H q
    is-trivial-quotient-hom-image-hom-element-is-emb-ev-element-hom-Group = {!!}

  is-surjective-hom-element-is-emb-ev-element-hom-Group :
    is-surjective-hom-element-Group G g
  is-surjective-hom-element-is-emb-ev-element-hom-Group x = {!!}
```

#### A group element `g : G` is generating if and only if for every group `H` the evaluation map `hom(G,H) → H` at `g` is an embedding

```agda
module _
  {l : Level} (G : Group l) (g : type-Group G)
  where

  abstract
    is-prop-map-ev-element-is-generating-element-Group :
      is-generating-element-Group G g → is-prop-map-ev-element-hom-Group G g
    is-prop-map-ev-element-is-generating-element-Group U H y = {!!}

  is-emb-ev-element-is-generating-element-Group :
    is-generating-element-Group G g → is-emb-ev-element-hom-Group G g
  is-emb-ev-element-is-generating-element-Group U H = {!!}

  is-generating-element-is-emb-ev-element-hom-Group :
    is-emb-ev-element-hom-Group G g → is-generating-element-Group G g
  is-generating-element-is-emb-ev-element-hom-Group U = {!!}

is-emb-ev-element-Group-With-Generating-Element :
  {l : Level} (G : Group-With-Generating-Element l) →
  is-emb-ev-element-hom-Group
    ( group-Group-With-Generating-Element G)
    ( element-Group-With-Generating-Element G)
is-emb-ev-element-Group-With-Generating-Element G = {!!}
```

### If `g` is a generating element of `G`, then `G` is abelian

```agda
module _
  {l : Level} (G : Group l) (g : type-Group G)
  where

  abstract
    commutative-mul-is-surjective-hom-element-Group :
      (U : is-surjective-hom-element-Group G g) →
      (x y : type-Group G) → commute-Group G x y
    commutative-mul-is-surjective-hom-element-Group U x y = {!!}

  commutative-mul-is-generating-element-Group :
    (U : is-generating-element-Group G g) →
    (x y : type-Group G) → commute-Group G x y
  commutative-mul-is-generating-element-Group U = {!!}

module _
  {l : Level} (G : Group-With-Generating-Element l)
  where

  abelian-group-Group-With-Generating-Element : Ab l
  pr1 abelian-group-Group-With-Generating-Element = {!!}

  zero-Group-With-Generating-Element :
    type-Group-With-Generating-Element G
  zero-Group-With-Generating-Element = {!!}

  add-Group-With-Generating-Element :
    (x y : type-Group-With-Generating-Element G) →
    type-Group-With-Generating-Element G
  add-Group-With-Generating-Element = {!!}

  neg-Group-With-Generating-Element :
    type-Group-With-Generating-Element G → type-Group-With-Generating-Element G
  neg-Group-With-Generating-Element = {!!}

  associative-add-Group-With-Generating-Element :
    (x y z : type-Group-With-Generating-Element G) →
    add-Group-With-Generating-Element
      ( add-Group-With-Generating-Element x y)
      ( z) ＝
    add-Group-With-Generating-Element
      ( x)
      ( add-Group-With-Generating-Element y z)
  associative-add-Group-With-Generating-Element = {!!}

  left-unit-law-add-Group-With-Generating-Element :
    (x : type-Group-With-Generating-Element G) →
    add-Group-With-Generating-Element zero-Group-With-Generating-Element x ＝ x
  left-unit-law-add-Group-With-Generating-Element = {!!}

  right-unit-law-add-Group-With-Generating-Element :
    (x : type-Group-With-Generating-Element G) →
    add-Group-With-Generating-Element x zero-Group-With-Generating-Element ＝ x
  right-unit-law-add-Group-With-Generating-Element = {!!}

  left-inverse-law-add-Group-With-Generating-Element :
    (x : type-Group-With-Generating-Element G) →
    add-Group-With-Generating-Element (neg-Group-With-Generating-Element x) x ＝
    zero-Group-With-Generating-Element
  left-inverse-law-add-Group-With-Generating-Element = {!!}

  right-inverse-law-add-Group-With-Generating-Element :
    (x : type-Group-With-Generating-Element G) →
    add-Group-With-Generating-Element x (neg-Group-With-Generating-Element x) ＝
    zero-Group-With-Generating-Element
  right-inverse-law-add-Group-With-Generating-Element = {!!}
```

### If `g` is a generating element of `G`, then the evaluation map `hom(G,G) → G` is an isomorphism of groups

```agda
module _
  {l : Level} (G : Group-With-Generating-Element l)
  where

  abstract
    is-surjective-ev-element-Group-With-Generating-Element :
      is-surjective
        ( ev-element-hom-Group-With-Generating-Element G
          ( group-Group-With-Generating-Element G))
    is-surjective-ev-element-Group-With-Generating-Element x = {!!}

  is-equiv-ev-element-Group-With-Generating-Element :
    is-equiv
      ( ev-element-hom-Group-With-Generating-Element G
        ( group-Group-With-Generating-Element G))
  is-equiv-ev-element-Group-With-Generating-Element = {!!}

  is-iso-ev-element-Group-With-Generating-Element :
    is-iso-Ab
      ( ab-hom-Ab
        ( abelian-group-Group-With-Generating-Element G)
        ( abelian-group-Group-With-Generating-Element G))
      ( abelian-group-Group-With-Generating-Element G)
      ( hom-ev-element-hom-Ab
        ( abelian-group-Group-With-Generating-Element G)
        ( abelian-group-Group-With-Generating-Element G)
        ( element-Group-With-Generating-Element G))
  is-iso-ev-element-Group-With-Generating-Element = {!!}

  iso-ev-element-Group-With-Generating-Element :
    iso-Ab
      ( ab-hom-Ab
        ( abelian-group-Group-With-Generating-Element G)
        ( abelian-group-Group-With-Generating-Element G))
      ( abelian-group-Group-With-Generating-Element G)
  pr1 iso-ev-element-Group-With-Generating-Element = {!!}
```

### Groups equipped with generating elements are commutative rings

```agda
module _
  {l : Level} (G : Group-With-Generating-Element l)
  where

  ring-Group-With-Generating-Element : Ring l
  ring-Group-With-Generating-Element = {!!}

  one-Group-With-Generating-Element : type-Group-With-Generating-Element G
  one-Group-With-Generating-Element = {!!}

  compute-one-Group-With-Generating-Element :
    one-Group-With-Generating-Element ＝
    element-Group-With-Generating-Element G
  compute-one-Group-With-Generating-Element = {!!}

  mul-Group-With-Generating-Element :
    (x y : type-Group-With-Generating-Element G) →
    type-Group-With-Generating-Element G
  mul-Group-With-Generating-Element = {!!}

  abstract
    commutative-mul-Group-With-Generating-Element :
      (x y : type-Group-With-Generating-Element G) →
      mul-Group-With-Generating-Element x y ＝
      mul-Group-With-Generating-Element y x
    commutative-mul-Group-With-Generating-Element x y = {!!}

  commutative-ring-Group-With-Generating-Element : Commutative-Ring l
  pr1 commutative-ring-Group-With-Generating-Element = {!!}
```

## See also

### Table of files related to cyclic types, groups, and rings

{{#include tables/cyclic-types.md}}
